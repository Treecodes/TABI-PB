#include <iostream>
#include <iomanip>
#include <cstdlib>

#include "params.h"
#include "molecule.h"
#include "elements.h"
#include "tree.h"
#include "interaction_list.h"
#include "boundary_element.h"
#include "tabipb_timers.h"
#include "output.h"


int main(int argc, char* argv[])
{
    // set the parameter struct, which is read in from file provided as argv
    if (argc < 2) { 
        std::cout << "No input file set. Exiting." << std::endl; 
        std::exit(1);
    }
    struct Params params(argv[1]);
    struct Timers timers;
    
    timers.tabipb.start();
    
    //construct the biomolecule from the provided pqr file
    class Molecule molecule(params, timers.molecule);
    class Tree mol_tree(molecule, params.tree_max_per_leaf_, timers.tree);
    class InterpolationPoints mol_interp_pts(mol_tree, params.tree_degree_);

    molecule.build_xyzr_file();
    molecule.copyin_to_device();
    mol_interp_pts.copyin_to_device();
    mol_interp_pts.compute_all_interp_pts();
    
    // build particles from a NanoShaper surface generated by xyzr file
    // then build a tree on the particles, partitioning them
    class Elements elements(molecule, params, timers.elements);
    class Tree elem_tree(elements, params.tree_max_per_leaf_, timers.tree);
    class InterpolationPoints elem_interp_pts(elem_tree, params.tree_degree_);
    
    elements.copyin_to_device();
    elem_interp_pts.copyin_to_device();
    elem_interp_pts.compute_all_interp_pts();

    class InteractionList mol_ilist(mol_tree, params.tree_degree_, params.tree_theta_,
                                    timers.interaction_list);
    class InteractionList elem_ilist(elem_tree, params.tree_degree_, params.tree_theta_,
                                    timers.interaction_list);
    class InteractionList mol_elem_ilist(elem_tree, mol_tree, params.tree_degree_, params.tree_theta_,
                                    timers.interaction_list);

    //elements.compute_source_term();
    elements.compute_source_term(elem_interp_pts, elem_tree, molecule, mol_interp_pts, mol_tree, mol_elem_ilist);
    
    
    /* energies, potential, and outfile routines are contained in output */
    class Output output(molecule, elements, params, timers.output);
    
    // initialize the boundary element method
    class BoundaryElement boundary_element(elements, elem_interp_pts, elem_tree, elem_ilist, molecule,
                                           params, output, timers.boundary_element);
    
    boundary_element.run_GMRES();

    class InteractionList mol_ilist2(mol_tree, params.tree_degree_, 0.0,
                                    timers.interaction_list);
    class InteractionList mol_elem_ilist2(elem_tree, mol_tree, params.tree_degree_, 0.0,
                                    timers.interaction_list);
        
    output.compute_coulombic_energy(mol_interp_pts, mol_tree, mol_ilist2);
    output.compute_solvation_energy(elem_interp_pts, elem_tree, mol_interp_pts, mol_tree, mol_elem_ilist2);
    
    //output.compute_coulombic_energy();
    //output.compute_solvation_energy();
    output.finalize();

    molecule.delete_from_device();
    mol_interp_pts.delete_from_device();
    
    elements.delete_from_device();
    elem_interp_pts.delete_from_device();
    
    timers.tabipb.stop();
    
    output.files(timers);
    
    return 0;
}
